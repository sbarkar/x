{"ast":null,"code":"import { baseZindex, foregroundZindex, MAXIMIZE_ANIMATION_SPEED_IN_SECONDS, MILLISECONDS_IN_SECOND, TASKBAR_HEIGHT, windowsZindexLevel, zindexLevelSize } from '@/utils/constants';\nimport { getMaxDimensions, getNextVisibleWindow } from '@/utils/windowmanager';\nimport { ProcessContext } from '@/contexts/ProcessManager';\nimport { SessionContext } from '@/contexts/SessionManager';\nimport { useContext, useEffect, useMemo, useState } from 'react';\nimport { windowMotionSettings } from '@/utils/motions';\nconst windowZindex = baseZindex + windowsZindexLevel * zindexLevelSize;\n\nconst useWindow = ({\n  loaderOptions: {\n    width: defaultWidth,\n    height: defaultHeight\n  },\n  processProps: {\n    height: initialHeight,\n    id,\n    launchElement,\n    lockAspectRatio,\n    maximized,\n    minimized,\n    taskbarElement,\n    width: initialWidth,\n    x,\n    y\n  }\n}) => {\n  const {\n    foreground,\n    getState,\n    saveState,\n    session: {\n      foregroundId,\n      stackOrder\n    }\n  } = useContext(SessionContext);\n  const {\n    processes,\n    close,\n    maximize,\n    minimize,\n    position,\n    restore,\n    size\n  } = useContext(ProcessContext);\n  const {\n    0: maximizeWindow,\n    1: setMaximizeWindow\n  } = useState(false);\n  const {\n    height,\n    width\n  } = getMaxDimensions(initialWidth, initialHeight, defaultWidth, defaultHeight, lockAspectRatio);\n  const {\n    x: previousX,\n    y: previousY\n  } = getState({\n    id\n  });\n  const {\n    x: defaultX,\n    y: defaultY\n  } = useMemo(() => ({\n    x: Math.floor((window.innerWidth - width) / 2),\n    y: Math.floor((window.innerHeight - height - TASKBAR_HEIGHT) / 2)\n  }), []);\n  const zIndex = windowZindex + stackOrder.slice().reverse().indexOf(id);\n  useEffect(() => {\n    if (foregroundId === id && minimized) {\n      foreground(getNextVisibleWindow(processes, stackOrder.filter(stackId => stackId !== id)));\n    } else if (!stackOrder.includes(id)) {\n      foreground(getNextVisibleWindow(processes, stackOrder));\n    }\n  }, [foregroundId, id, minimized, processes, stackOrder]);\n  useEffect(() => {\n    if (maximized) {\n      setMaximizeWindow(true);\n    } else if (maximizeWindow) {\n      setTimeout(() => setMaximizeWindow(false), MAXIMIZE_ANIMATION_SPEED_IN_SECONDS * MILLISECONDS_IN_SECOND);\n    }\n  }, [maximized, maximizeWindow]);\n  return {\n    height,\n    width,\n    zIndex: foregroundId === id ? foregroundZindex : zIndex,\n    motions: windowMotionSettings({\n      animation: maximized && minimized && 'maxmin' || maximized && 'maximized' || minimized && 'minimized' || 'start',\n      initialX: previousX || defaultX,\n      initialY: previousY || defaultY,\n      x,\n      y,\n      taskbarElement,\n      launchElement,\n      height,\n      width,\n      zIndex\n    }),\n    settings: {\n      onBlur: event => {\n        if (event.relatedTarget !== taskbarElement) {\n          foreground('');\n        }\n      },\n      onClose: () => {\n        saveState({\n          id,\n          height,\n          width,\n          x: !previousX ? defaultX + x : x,\n          y: !previousY ? defaultY + y : y\n        });\n        close(id);\n      },\n      onDrag: position(id),\n      onFocus: () => foreground(id),\n      onMaximize: () => maximized ? restore(id, 'maximized') : maximize(id),\n      onMinimize: () => minimize(id),\n      onResize: size(id),\n      height,\n      id,\n      lockAspectRatio,\n      maximized: maximizeWindow,\n      minimized,\n      width,\n      zIndex\n    }\n  };\n};\n\nexport default useWindow;","map":null,"metadata":{},"sourceType":"module"}